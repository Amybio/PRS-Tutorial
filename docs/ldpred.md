Here we use another PRS program, [LDpred](https://github.com/bvilhjal/ldpred), that uses a Bayesian approach to polygenic risk scoring.


!!! note
    The script used here is based on LDpred 2 implemented under bigsnpr version 1.4.7

!!! note
    For more details, please refer to [LDpred 2's homepage](https://privefl.github.io/bigsnpr/articles/LDpred2.html)

You can install `LDpred` and its dependencies in `R` with the following command:

```R
install.packages("remotes")
library(remotes)
remotes::install_github("https://github.com/privefl/bigsnpr.git")
```

!!! note
    For mac users, you might need to follow the guide [here](https://thecoatlessprofessor.com/programming/cpp/openmp-in-r-on-os-x/) to be able to install LDpred2


We assume that you have the following files:

|File Name | Description|
|:-:|:-:|
|**Height.QC.gz**| The post-QCed summary statistic |
|**EUR.QC.bed**| The genotype file after performing some basic filtering |
|**EUR.QC.bim**| This file contains the SNPs that passed the basic filtering |
|**EUR.QC.fam**| This file contains the samples that passed the basic filtering |
|**EUR.height**| This file contains the phenotype of the samples |
|**EUR.covariate**| This file contains the covariates of the samples |
|**EUR.eigenvec**| This file contains the PCs of the samples |


# Running PRS analysis

1. Read in the phenotype and covariate files
```R
library(data.table)
library(magrittr)
phenotype <- fread("EUR.height")
covariate <- fread("EUR.covariate")
pcs <- fread("EUR.eigenvec")
# rename columns
colnames(pcs) <- c("FID","IID", paste0("PC",1:6))
# generate required table
pheno <- merge(phenotype, covariate) %>%
    merge(., pcs)
``` 
2. Load in the genotype and summary statistic file using bigsnpr
``` R
# load the library
library(bigsnpr)
# now preprocess the bed file. Only need to do once for each data set
snp_readBed("EUR.QC.bed")
# now attach the genotype object
obj.bigSNP <- snp_attach("EUR.QC.rds")
# Next, read in the summary statistic file
sumstats <- bigreadr::fread2("Height.QC.gz")
```

3. Reformat data in preparation of LDpred2
```R
# LDpred 2 require the header to follow the exact naming
names(sumstats) <- c("rsid", "chr", "pos", "a1", "a0", "MAF", "beta_se", "p", "n_eff", "INFO", "OR")
# Transform the OR into log(OR)
# Our SE is the SE of beta. 
# If the SE is the SE of OR, you will need to transform it (which we will not go into)
sumstats$beta <- log(sumstats$OR)
# extract the SNP information from the genotype
map <- obj.bigSNP$map[-(2:3)]
names(map) <- c("chr", "pos", "a1", "a0")
# perform SNP matching
info_snp <- snp_match(sumstats, map)

# Rename the data structures
CHR <- obj.bigSNP$map$chromosome
POS <- obj.bigSNP$map$physical.pos
# get the CM information from 1000 Genome, will download the 1000G file
POS2 <- snp_asGeneticPos(CHR, POS, dir = ".")
# Reformat the phenotype information to match the fam order
fam.order <- as.data.table(obj.bigSNP$fam)
setnames(fam.order, 
            c("family.ID", "sample.ID"), 
            c("FID", "IID"))
# This will ensure our phenotype vector y is of the same order as the 
# family object generated by bigsnpr
y <- pheno[fam.order, on=c("FID", "IID")]
genotype <- obj.bigSNP$genotypes
NCORES <- nb_cores()
# Use all sample for test
ind.test <- 1:nrow(genotype)
# Prepare data for grid model
p_seq <- signif(seq_log(1e-4, 1, length.out = 17), 2)
# Calculate the null R2
# use glm for binary trait (will also need the fmsb package to calculate the pseudo R2)
null.model <- paste("PC",1:6, sep="", collapse="+") %>% 
    paste0("Height~Sex+", .) %>%
    as.formula %>%
    lm(., data=y) %>%
    summary
null.r2 <- null.model$r.squared
reg.formula <- paste("PC",1:6, sep="", collapse="+") %>% 
    paste0("Height~PRS+Sex+", .) %>% 
    as.formula

```

4. Start running LDpred 2
```R
# Start doing analysis on each chromosome
y[,Inf.est:=0]
y[,auto:=0]
y[,grid:=0]
# add progress bar
pb = txtProgressBar(min = 0, max = 22, initial = 0) 
for(chr in 1:22){
    setTxtProgressBar(pb,chr)
    chr.idx <- which(info_snp$chr == chr)
    df_beta <- info_snp[chr.idx, 
                c("beta", "beta_se", "n_eff")]
    ind.chr <- info_snp$`_NUM_ID_`[chr.idx]
    corr0 <- snp_cor(genotype, ind.col = ind.chr, ncores = NCORES,
                 infos.pos = POS2[ind.chr], size = 3 / 1000)
    corr <- bigsparser::as_SFBM(as(corr0, "dgCMatrix"))
    ldsc <- snp_ldsc2(corr0, df_beta)
    h2_est <- ldsc[["h2"]]
    h2_seq <- round(h2_est * c(0.7, 1, 1.4), 4)
    grid.param <- expand.grid(p = p_seq, h2 = h2_seq, sparse = c(FALSE, TRUE))
    # Get adjusted beta from infinitesimal model
    beta_inf <- snp_ldpred2_inf(corr, df_beta, h2 = h2_est)
    # Get adjusted beta from grid model
    beta_grid <- snp_ldpred2_grid(corr, df_beta, grid.param, ncores = NCORES)
    # Get adjusted beta from the auto model
    multi_auto <- snp_ldpred2_auto(corr, df_beta, h2_init = h2_est,
                               vec_p_init = seq_log(1e-4, 0.9, length.out = NCORES),
                               ncores = NCORES)
    pred_auto <- big_prodMat(genotype, beta_auto, ind.row = ind.val, ind.col = ind.chr2)
    # scale the PRS generated from AUTO
    pred_scaled <- apply(pred_auto, 2, sd)
    final_beta_auto <- rowMeans(beta_auto[, abs(sc - median(sc)) < 3 * mad(sc)])
    pred_auto <- big_prodMat(genotype, final_beta_auto, ind.row = ind.val, ind.col = ind.chr2)
    # Get infinitesimal PRS
    pred_inf <- big_prodVec(genotype, beta_inf, ind.row = ind.test, ind.col = ind.chr)
    # Get the grid PRSs
    pred_grid <- big_prodMat(genotype, beta_grid, ind.col = ind.chr)
    # Get the Auto PRS
    pred_auto <- big_prodMat(genotype, beta_auto, ind.row = ind.test, ind.col = ind.chr)
    # add up the calculated PRS
    y[,Inf.est:=Inf.est+pred_inf]
    # for auto and grid, we want to retain the "best" prs only?
    indep <- copy(y) 
    max.grid.r2 <- 0
    max.grid.id <- 0
    for(i in 1:ncol(pred_grid)){
        indep[,PRS:=pred_grid[,i]]
        model <- lm(reg.formula, data=indep) %>%
            summary
        prs.r2 <- model$r.squared - null.r2
        if(max.grid.r2 < prs.r2){
            max.grid.r2 <- prs.r2
            max.grid.id <- i
        }
    }
    # add up the calculated grid PRS
    y[,grid:=grid+pred_grid[,max.grid.id]]
    # Do the same for auto
    max.auto.r2 <- 0
    max.auto.id <- 0
    for(i in 1:ncol(pred_auto)){
        indep[,PRS:=pred_auto[,i]]
        model <- lm(reg.formula, data=indep) %>%
            summary
        prs.r2 <- model$r.squared - null.r2
        if(max.auto.r2 < prs.r2){
            max.auto.r2 <- prs.r2
            max.auto.id <- i
        }
    }
    # add up the calculated grid PRS
    y[,auto:=auto+pred_auto[,max.auto.id]]
}
print("Completed")
```

5. Get the final performance of the LDpred models
```R
    # there are 3 models: inf, auto and grid
    inf.model <- paste("PC",1:6, sep="", collapse="+") %>% 
        paste0("Height~Inf.est+Sex+", .) %>% 
        as.formula %>%
        lm(., data=y) %>%
        summary
    auto.model <- paste("PC",1:6, sep="", collapse="+") %>% 
        paste0("Height~auto+Sex+", .) %>% 
        as.formula %>%
        lm(., data=y) %>%
        summary
    grid.model <- paste("PC",1:6, sep="", collapse="+") %>% 
        paste0("Height~grid+Sex+", .) %>% 
        as.formula %>%
        lm(., data=y) %>%
        summary

    result <- data.table(   
                infinitesimal=inf.model$r.squared-null.r2,
                grid=grid.model$r.squared-null.r2,
                auto=auto.model$r.squared-null.r2,
                null=null.r2)
    print(result)
```